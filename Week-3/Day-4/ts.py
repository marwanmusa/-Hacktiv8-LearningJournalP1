# -*- coding: utf-8 -*-
"""TS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_j7s3xBTxp9iFwDZcopleyIq3idt92yc

### Airline Data
"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf
from statsmodels.graphics.tsaplots import plot_pacf
import warnings
warnings.filterwarnings('ignore')

import pandas as pd
from statsmodels.tsa.arima_model import ARMA
from statsmodels.tsa.arima_model import ARIMA

passenger=pd.read_csv('https://raw.githubusercontent.com/anejad/QuantJam_Notebooks/main/data/AirPassengers.csv')
passenger

passenger.info()

passenger.columns=['Date','Passengers']
passenger.Date=pd.to_datetime(passenger.Date)
passenger.set_index('Date',inplace=True)
passenger.plot()
plt.xlabel('Date')
plt.ylabel('Num of Passengers')

passenger.head()

from statsmodels.tsa.seasonal import seasonal_decompose
import pylab

pylab.rcParams['figure.figsize'] = (14, 9)
res = seasonal_decompose(passenger['Passengers'],model='multiplicatif')
ax=res.plot()
plt.show()

"""**Stasionarity**"""

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('without differencing')
ax1.plot(passenger['Passengers'])

def check_stationarity(series):
    # Copied from https://machinelearningmastery.com/time-series-data-stationary-python/

    result = adfuller(series.values)

    print('ADF Statistic: %f' % result[0])
    print('p-value: %f' % result[1])
    print('Critical Values:')
    for key, value in result[4].items():
        print('\t%s: %.3f' % (key, value))

    if (result[1] <= 0.05) & (result[4]['5%'] > result[0]):
        print("\u001b[32mStationary\u001b[0m")
    else:
        print("\x1b[31mNon-stationary\x1b[0m")

check_stationarity(passenger['Passengers'])

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('1st order differencing')
ax1.plot(passenger['Passengers'].diff())

print("1st order differencing")
check_stationarity(passenger['Passengers'].diff().dropna())

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('2nd order differencing')
ax1.plot(passenger['Passengers'].diff().diff())

print("2nd order differencing")
check_stationarity(passenger['Passengers'].diff().diff().dropna())

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('3rd order differencing')
ax1.plot(passenger['Passengers'].diff().diff().diff())

"""

```
AR: acf tail off & pacf cut off -> nilai AR(p)=cut off ke berapa
```

```
MA: acf cut off & pacf tail off -> nilai MA(q)=cut off ke berapa
```

```
ARMA: acf & pacf cut off, nilai cut off dipakai utk jd p atai q
```"""

plot_acf(passenger['Passengers'])
plot_pacf(passenger['Passengers'])
plt.show()

plot_acf(passenger['Passengers'].diff().dropna())
plot_pacf(passenger['Passengers'].diff().dropna())
plt.show()

plot_acf(passenger['Passengers'].diff().diff().dropna())
plot_pacf(passenger['Passengers'].diff().diff().dropna())
plt.show()

def find_best_model(data,num_p,num_q):
    df=pd.DataFrame() #We make a pandas dataframe to ease our work, you can use any way that makes you comfortable and work easly
    pq=[[],[]] #This list for storing the combinations of p and q
    aic=[] # This list for storing aic value
    for p in range(num_p+1): #plus one is to make the range up to num_p since python range only ranging from 0 to N-1
        for q in range(num_q+1):
            #if p!=0 and q!=0: #this logic will avoid (0,0) value which is not correct
                try: #Using exception to avoid the error while training the model with certain p and q value
                    model=ARMA(data,order=(p,q))
                    result=model.fit()
                    pq[0].append(p)
                    pq[1].append(q)
                    aic.append(result.aic)
                except:
                    pass #If there is an error caused by the calculation, it will be skipped to the next iteration
    df['p']=pq[0]
    df['q']=pq[1]
    df['AIC']=aic
    
    df.sort_values('AIC',inplace=True)
    
    return df.p.iloc[0],df.q.iloc[0],df.AIC.iloc[0],df

mod_ar = ARIMA(passenger, order=(4,2,2))

res1=mod_ar.fit()

res1.aic

find_best_model(passenger,5,5)

def find_best_model(data,num_p,num_d,num_q):
    df=pd.DataFrame() #We make a pandas dataframe to ease our work, you can use any way that makes you comfortable and work easly
    pdq=[[],[],[]] #This list for storing the combinations of p and q
    aic=[] # This list for storing aic value
    for p in range(num_p+1): #plus one is to make the range up to num_p since python range only ranging from 0 to N-1
        for d in range(num_d+1):
          for q in range(num_q+1):
            #if p!=0 and q!=0: #this logic will avoid (0,0) value which is not correct
                try: #Using exception to avoid the error while training the model with certain p and q value
                    model=ARIMA(data,order=(p,d,q))
                    result=model.fit()
                    pdq[0].append(p)
                    pdq[1].append(d)
                    pdq[2].append(q)
                    aic.append(result.aic)
                except:
                    pass #If there is an error caused by the calculation, it will be skipped to the next iteration
    df['p']=pdq[0]
    df['d']=pdq[1]
    df['q']=pdq[2]
    df['AIC']=aic
    
    df.sort_values('AIC',inplace=True)
    
    return df.p.iloc[0],df.d.iloc[0],df.q.iloc[0],df.AIC.iloc[0],df

find_best_model(passenger,5,3,5)

!pip install pyramid

mod_ar = ARMA(passenger, order=(1,0)) 
res1=mod_ar.fit()
mod_ma = ARMA(passenger, order=(0,1)) 
res2=mod_ma.fit()
mod_arma = ARMA(passenger, order=(1,1)) 
res3=mod_arma.fit()

mod_arima=ARMA(passenger, order=(3,0)) 
res4=mod_arima.fit()
print('The AIC is',res4.aic)

mod_arima=ARIMA(passenger, order=(5,1,2)) 
res5=mod_arima.fit()
print('The AIC is',res5.aic)

mod_arima=ARIMA(passenger['Passengers'], order=(1,1,1)) 
res6=mod_arima.fit()
print('The AIC is',res6.aic)

mod_arima=ARIMA(passenger['Passengers'], order=(2,2,2)) 
res7=mod_arima.fit()
print('The AIC is',res7.aic)

mod_arima=ARIMA(passenger['Passengers'].diff().dropna(), order=(1,2,1)) 
res8=mod_arima.fit()
print('The AIC is',res8.aic)

print('The AIC of AR model is',res1.aic)
print('The AIC of MA model is',res2.aic)
print('The AIC of ARMA model is',res3.aic)
print('The AIC of ARIMA=ARMA model is',res4.aic)
print('The AIC of ARIMA_diff1 model is',res5.aic)
print('The AIC of ARIMA_diff1 model is',res6.aic)
print('The AIC of ARIMA_diff2 model is',res7.aic)
print('The AIC of ARIMA_diff3 model is',res8.aic)

fig,ax=plt.subplots(figsize=(15,3))
res1.plot_predict(start=0, end=len(passenger)+48,ax=ax)
plt.show()
fig,ax=plt.subplots(figsize=(15,3))
res2.plot_predict(start=0, end=len(passenger)+48,ax=ax)
plt.show()
fig,ax=plt.subplots(figsize=(15,3))
res3.plot_predict(start=0, end=len(passenger)+48,ax=ax)
plt.show()
fig,ax=plt.subplots(figsize=(15,3))
res4.plot_predict(start=0, end=len(passenger)+48,ax=ax)
plt.show()
res5.plot_predict(dynamic=False)
plt.show()

st=passenger.shape[0]
nd=st+48

new_pred=res4.predict(st,nd)
new_pred=pd.DataFrame(new_pred)
new_pred.columns=['Passengers']

pass_pred=pd.concat([passenger,new_pred], axis=0)

new_pred.head()

pass_pred

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('Forecasting using ARMA')
ax1.plot(pass_pred)

new_pred_ARIMA=pd.Series(res7.forecast(49)[0],index=new_pred.index)
new_pred_ARIMA=pd.DataFrame(new_pred_ARIMA)
new_pred_ARIMA.columns=['Passengers']

pass_pred_ARIMA=pd.concat([passenger,new_pred_ARIMA], axis=0)

fig,ax=plt.subplots(figsize=(15,5))
ax1= fig.add_subplot(111)
ax1.set_title('Forecasting using ARIMA')
ax1.plot(pass_pred_ARIMA)

"""**Split Train dan Test**"""

train=passenger[:100]
test=passenger[100:]

# check stasioneritas
print("data train stasionarity")
check_stationarity(train['Passengers'])

# differencing data non-stasioner
print("data train_diff1 stasionarity")
check_stationarity(train['Passengers'].diff().dropna())

# differencing data non-stasioner
print("data train_diff2 stasionarity")
check_stationarity(train['Passengers'].diff().diff().dropna())

# check plot pacf dan acf
plot_acf(train['Passengers'].diff().diff().dropna())
plot_pacf(train['Passengers'].diff().diff().dropna())
plt.show()

arima=ARIMA(train,order=(2,2,2))
mod_train=arima.fit()
mod_train.aic

y_pred_train=pd.Series(mod_train.forecast(100)[0],index=train.index)
y_pred_train=pd.DataFrame(y_pred_train)
y_pred_train.columns=['Passengers_predict']

y_pred_train

passenger.shape

y_pred_test=pd.Series(mod_train.forecast(44)[0],index=test.index)
y_pred_test=pd.DataFrame(y_pred_test)
y_pred_test.columns=['Passengers_predict']

act_vs_pred=pd.concat([test,y_pred_test], axis=1)
act_vs_pred

from sklearn.metrics import mean_absolute_error,mean_squared_error
import numpy as np

print('MAE train = ', mean_absolute_error(train, y_pred_train))
print('MAE test = ', mean_absolute_error(test, y_pred_test))

print('MSE train = ', mean_squared_error(train, y_pred_train))
print('MSE test = ', mean_squared_error(test, y_pred_test))

print('RMSE train = ', np.sqrt(mean_squared_error(train, y_pred_train)))
print('RMSE test = ', np.sqrt(mean_squared_error(test, y_pred_test)))

"""# **SARIMA**"""

import statsmodels.api as sm

sar=sm.tsa.statespace.SARIMAX(train['Passengers'], order=(1, 1, 1),seasonal_order=(1,1,1,7)).fit()
sar.summary()

sar_pred_test = sar.predict(start="1957-05-01", end="1960-12-01", dynamic=True)
sar_pred_test=pd.DataFrame(sar_pred_test)
sar_pred_test.columns=['Passengers_predict']
sar_pred_test

act_vs_pred_sar=pd.concat([test,sar_pred_test], axis=1)
act_vs_pred_sar

print('MAE test = ', mean_absolute_error(test, sar_pred_test))
print('MSE test = ', mean_squared_error(test, sar_pred_test))
print('RMSE test = ', np.sqrt(mean_squared_error(test, sar_pred_test)))